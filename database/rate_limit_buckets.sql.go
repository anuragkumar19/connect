// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: rate_limit_buckets.sql

package database

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRateLimitBucket = `-- name: CreateRateLimitBucket :one
INSERT INTO
    "rate_limit_buckets" (
        "id",
        "last_reset_at",
        "consumed",
        "last_consumed_at"
    )
VALUES
    ($1, $2, $3, $4)
ON CONFLICT DO NOTHING
RETURNING
    id, created_at, last_reset_at, consumed, last_consumed_at
`

type CreateRateLimitBucketParams struct {
	ID             string
	LastResetAt    time.Time
	Consumed       int64
	LastConsumedAt pgtype.Timestamptz
}

func (q *Queries) CreateRateLimitBucket(ctx context.Context, arg *CreateRateLimitBucketParams) (RateLimitBucket, error) {
	row := q.db.QueryRow(ctx, createRateLimitBucket,
		arg.ID,
		arg.LastResetAt,
		arg.Consumed,
		arg.LastConsumedAt,
	)
	var i RateLimitBucket
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastResetAt,
		&i.Consumed,
		&i.LastConsumedAt,
	)
	return i, err
}

const getRateLimitBucketForUpdate = `-- name: GetRateLimitBucketForUpdate :one
SELECT
    id, created_at, last_reset_at, consumed, last_consumed_at
FROM
    "rate_limit_buckets"
WHERE
    "id" = $1
FOR UPDATE
`

func (q *Queries) GetRateLimitBucketForUpdate(ctx context.Context, id string) (RateLimitBucket, error) {
	row := q.db.QueryRow(ctx, getRateLimitBucketForUpdate, id)
	var i RateLimitBucket
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.LastResetAt,
		&i.Consumed,
		&i.LastConsumedAt,
	)
	return i, err
}

const updateRateLimitBucket = `-- name: UpdateRateLimitBucket :exec
UPDATE "rate_limit_buckets"
SET
    "last_reset_at" = $1,
    "consumed" = $2,
    "last_consumed_at" = $3
WHERE
    "id" = $4
`

type UpdateRateLimitBucketParams struct {
	LastResetAt    time.Time
	Consumed       int64
	LastConsumedAt pgtype.Timestamptz
	ID             string
}

func (q *Queries) UpdateRateLimitBucket(ctx context.Context, arg *UpdateRateLimitBucketParams) error {
	_, err := q.db.Exec(ctx, updateRateLimitBucket,
		arg.LastResetAt,
		arg.Consumed,
		arg.LastConsumedAt,
		arg.ID,
	)
	return err
}
