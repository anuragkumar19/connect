// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	ulid "github.com/oklog/ulid/v2"
)

const createUser = `-- name: CreateUser :exec
INSERT INTO
    "users" (
        "id",
        "is_registered",
        "name",
        "username",
        "primary_email_id",
        "primary_phone_number_id"
    )
VALUES
    ($1, $2, $3, $4, $5, $6)
`

type CreateUserParams struct {
	ID                   ulid.ULID
	IsRegistered         bool
	Name                 string
	Username             string
	PrimaryEmailID       ULIDValue
	PrimaryPhoneNumberID ULIDValue
}

func (q *Queries) CreateUser(ctx context.Context, arg *CreateUserParams) error {
	_, err := q.db.Exec(ctx, createUser,
		arg.ID,
		arg.IsRegistered,
		arg.Name,
		arg.Username,
		arg.PrimaryEmailID,
		arg.PrimaryPhoneNumberID,
	)
	return err
}

const isUsernameAvailable = `-- name: IsUsernameAvailable :one
SELECT
    NOT EXISTS (
        SELECT
            1
        FROM
            "users"
        WHERE
            "users"."username" = $1
            AND "users"."is_registered"
    )
    AND NOT EXISTS (
        SELECT
            1
        FROM
            "reserved_usernames"
        WHERE
            "reserved_usernames"."username" = $1
    ) AS "is_username_available"
`

func (q *Queries) IsUsernameAvailable(ctx context.Context, username string) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, isUsernameAvailable, username)
	var is_username_available pgtype.Bool
	err := row.Scan(&is_username_available)
	return is_username_available, err
}
